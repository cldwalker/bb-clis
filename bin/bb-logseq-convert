#!/usr/bin/env bb
; vim: set filetype=clojure:
; Converts a url into a set of markdown properties for use
; as a multi-line logseq block

;; Setup: npm install -g rdf-dereference

(deps/add-deps '{:deps {io.github.cldwalker/bb-clis {:git/sha "c5da64153fb29e2f3fa807df4228b6e434f00fcd"}}})
; (deps/add-deps {:deps {'io.github.cldwalker/bb-clis {:local/root (str (fs/parent (fs/parent *file*)))}}})

(ns bb-logseq-convert
  (:require [cldwalker.bb-clis.cli :as cli]
            [cldwalker.bb-clis.cli.logseq :as logseq]
            [clojure.string :as str]
            [clojure.set :as set]
            [clojure.edn :as edn]
            [clojure.java.io :as io]
            [cheshire.core :as json]
            [babashka.process :as process]
            [babashka.tasks :refer [shell]])
  (:import (java.net URL)
           (java.io StringWriter)))

;; Config
;; ======
(def default-config
  ;; Configures what properties a given host keeps from rdf data to be converted
  ;; to a block.
  {:host-properties {}
   ;; Maps property urls that have text values to their names in logseq.
   ;; This also translates property values to normal strings by stripping them
   ;; of quotes and other suffix info e.g. "foo"@en -> foo
   :text-properties {}
   ;; Vec of url regexs to extract property info from. Extracts on first
   ;; matching regex
   :url-properties []})

;; May need to move this to shared ns
(defn- read-config []
  (let [config-file (io/file (System/getenv "HOME") ".bb-logseq" "config.edn")]
    (if (.exists config-file)
      (edn/read-string (slurp (str config-file)))
      default-config)))

(defn- read-entities-config
  "This is a map of urls to names. Entities are logseq pages or blocks that have
  url attributes.

This is a separate file as it is expected to be autogenerated by a script e.g. a
process that generates this map from your logseq data"
  []
  (let [config-file (io/file (System/getenv "HOME") ".bb-logseq" "entities.edn")]
    (if (.exists config-file)
      (edn/read-string (slurp (str config-file)))
      {})))

;; General util
;; ============
(defn- ->url-object [url]
  (try (URL. url)
    (catch Exception _ nil)))

(defn- process-by-timeout
  "Runs cmd which returns output as string. If timeout ms is reached, returns
  what has been written to stdout"
  [cmd timeout]
  (let [out-str (StringWriter.)
        ret (deref (:out (process/process cmd {:out out-str})) timeout ::timeout)]
    (if (= ret ::timeout)
      (str out-str)
      (str ret))))

;; Main CLI
;; ========
(defn- get-url-properties [url-obj {:keys [url-properties]} {:keys [debug]}]
  (let [url (str url-obj)
        props
        (some (fn [[regex-str {:keys [properties capture-names]}]]
                (when-let [matches (re-find (re-pattern regex-str) url)]
                  (when debug (println "[DEBUG] Matched regex:" regex-str))
                  (merge properties
                         (when (coll? matches)
                           (zipmap capture-names (rest matches))))))
              url-properties)]
    (when debug (println "[DEBUG] Url properties:" (pr-str props)))
    props))

(defn- translate-triple
  [{:keys [predicate object]} {:keys [text-property-urls url-to-name]}]
  (let [property-name (or (keyword (url-to-name predicate))
                          (throw (ex-info "Can't translate url to logseq property" {:url predicate})))
        value (if (contains? text-property-urls predicate)
                (or (->> object (re-find #"^\"\s*(.*)\s*\"") second)
                    object)
                object)
        value_ (if (->url-object value)
                 (or (url-to-name value)
                     ;; For cases like http://schema.org/Person with https://gist.github.com/borkdude
                     (url-to-name (str/replace-first value "http://" "https://"))
                     value)
                 value)]
    [property-name value_]))

(defn- build-dynamic-config
  [{:keys [text-properties entities]}]
  ;; Just add config for all https assuming all are described as http
  (let [new-text-properties
        (merge text-properties
               (into {}
                     (map (fn [[k v]]
                            ;; e.g. https://schema.description for SO
                            [(str/replace-first k "http://" "https://")
                             v])
                          text-properties)))]
    {:text-property-urls
     (set (keys new-text-properties))
     :url-to-name
     (merge
      entities
      ;; override entities for abbreviated names like description -> desc
      new-text-properties
      ;; Not configurable for now as type is pretty critical to how all this
      ;; rdf data is converted
      {"http://www.w3.org/1999/02/22-rdf-syntax-ns#type" "type"})}))

(defn- get-rdf-properties* [triples url-obj config {:keys [debug]}]
  (let [dynamic-config (build-dynamic-config config)
        host (str/replace-first (.getHost url-obj) #"^www\." "")
        _ (when debug (println "[DEBUG] Host: " host))
        properties-to-keep (get-in config [:host-properties host]
                                   #{"http://www.w3.org/1999/02/22-rdf-syntax-ns#type"})
        _ (when debug (println "[DEBUG] Rdf Properties: " (pr-str properties-to-keep)))
        properties (->> triples
                        (filter #(contains? properties-to-keep (:predicate %)))
                        (map #(translate-triple % dynamic-config))
                        (into {}))]
    properties))

(defn get-rdf-properties [url-obj config options]
  (let [triples (try (-> ["rdf-dereference" (str url-obj)]
                         ;; Need a timeout as rdf-dereference has been wierdly hanging
                         ;; out for imdb and wikipedia
                         (process-by-timeout 2500)
                         (json/parse-string true)
                         doall)
                  ;; nytimes intermittently fails on partially streamed data
                  (catch Exception e
                    (println "Rdf properties unexpectedly failed with: " (str e))))]
    (when triples
      (get-rdf-properties* triples url-obj config options))))

(defn- url->properties [url-obj config options]
  (merge (get-rdf-properties url-obj config options)
         (get-url-properties url-obj config options)))

(defn- create-block [arguments options]
  (let [entities (read-entities-config)
        config (assoc (read-config)
                      :entities entities)
        url (if (seq arguments)
              (str/join " " arguments)
              (:out (shell {:out :string} "pbpaste")))
        url-obj (or (->url-object url)
                    (cli/error "The following is not a url -" (pr-str url)))
        properties (merge {:desc "" :url (str url-obj)}
                          (url->properties url-obj config options))
        ;; Keep first properties in order
        ordered-properties [:url :type :name :desc]
        properties-coll (concat (keep #(when-let [val (properties %)] [% val])
                                      ordered-properties)
                                (map (juxt identity properties)
                                     (set/difference (set (keys properties))
                                                     (set ordered-properties))))
        block-text (logseq/properties->block properties-coll)]
    (shell {:in block-text} "pbcopy")
    (println block-text)))

(defn -main [{:keys [options arguments summary]}]
  (if (:help options)
    (cli/print-summary " [& LOGSEQ_TEXT]" summary)
    (create-block arguments options)))

(def cli-options
  [["-h" "--help"]
   ["-d" "--debug"]])

(when (= *file* (System/getProperty "babashka.file"))
  (cli/run-command -main *command-line-args* cli-options))
